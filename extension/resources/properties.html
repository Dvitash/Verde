<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Properties</title>
    <link href="[[styleUri]]" rel="stylesheet">
</head>

<body>
    <div class="root">
        [[topbarHtml]]
        <div id="scroller" class="scroller">
            <div id="properties-container"></div>
        </div>
    </div>

    <div id="curve-editor-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <span id="curve-editor-title" class="modal-title">Edit NumberSequence</span>
                <button class="modal-close" onclick="closeCurveEditor()">×</button>
            </div>
            <div class="modal-body">
                <div id="curve-canvas-container">
                    <canvas id="curve-canvas" width="500" height="250"></canvas>
                </div>
                <div id="curve-nodes-list" class="curve-nodes-list"></div>
                <div class="curve-controls">
                    <button onclick="addCurveNode()" class="curve-button">Add Node</button>
                </div>
            </div>
            <div class="modal-footer">
                <button onclick="applyCurveEditor()" class="curve-button primary">Apply</button>
                <button onclick="closeCurveEditor()" class="curve-button">Cancel</button>
            </div>
        </div>
    </div>

    <div id="gradient-editor-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <span id="gradient-editor-title" class="modal-title">Edit ColorSequence</span>
                <button class="modal-close" onclick="closeGradientEditor()">×</button>
            </div>
            <div class="modal-body">
                <div id="gradient-preview-container" class="gradient-preview-container">
                    <div id="gradient-preview" class="gradient-preview"></div>
                    <div id="gradient-stops" class="gradient-stops"></div>
                </div>
                <div id="gradient-stops-list" class="gradient-stops-list"></div>
            </div>
            <div class="modal-footer">
                <button onclick="applyGradientEditor()" class="curve-button primary">Apply</button>
                <button onclick="closeGradientEditor()" class="curve-button">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const vscode = acquireVsCodeApi();

        let allProperties = [];
        let allTags = [];
        let allAttributes = [];
        const collapsedCategories = new Set();
        const expandedProperties = new Set();
        let currentCurveProperty = null;
        let currentCurveNodes = [];
        let curveCanvas = null;
        let curveCtx = null;
        let draggingNodeIndex = -1;
        let selectedNodeIndex = -1;
        let currentGradientProperty = null;
        let currentGradientStops = [];
        let draggingGradientStopIndex = -1;
        let selectedGradientStopIndex = -1;
        let showTagInput = false;
        let showAttributeModal = false;
        let currentContextMenu = null;
        let renamingAttribute = null;

        const container = document.getElementById("properties-container");
        [[scriptElements]]

        function updateProperties(message) {
            if (typeof message === 'object') {
                if (message.properties && message.properties.properties) {
                    allProperties = Array.isArray(message.properties.properties) ? message.properties.properties : [];
                    allTags = Array.isArray(message.properties.tags) ? message.properties.tags : [];
                    allAttributes = Array.isArray(message.properties.attributes) ? message.properties.attributes : [];
                } else if (message.properties) {
                    allProperties = Array.isArray(message.properties) ? message.properties : [];
                    allTags = [];
                    allAttributes = [];
                }

                if (message.nodeName && message.nodeClassName) {
                    const titleElement = document.getElementById('properties-title');
                    if (titleElement) {
                        titleElement.textContent = `Properties - ${message.nodeClassName} - ${message.nodeName}`;
                    }
                }
            } else {
                allProperties = Array.isArray(message) ? message : [];
                allTags = [];
                allAttributes = [];
            }
            render();
        }

        function groupByCategory(properties) {
            const categories = new Map();
            for (const prop of properties) {
                const categoryName = (prop.category || "Other").toString();
                if (!categories.has(categoryName)) categories.set(categoryName, []);
                categories.get(categoryName).push(prop);
            }
            return categories;
        }

        function matchesFilter(prop) {
            [[filterLogic]]
        }

        function render() {
            container.innerHTML = "";

            const filtered = allProperties.filter(matchesFilter);
            if (filtered.length === 0 && allTags.length === 0 && allAttributes.length === 0) {
                const empty = document.createElement("div");
                empty.className = "empty";
                empty.textContent = "No properties, tags, or attributes available.";
                container.appendChild(empty);
                return;
            }

            const categories = groupByCategory(filtered);
            const sortedCategoryNames = Array.from(categories.keys()).sort((a, b) => a.localeCompare(b));

            for (const categoryName of sortedCategoryNames) {
                const categoryProps = categories.get(categoryName) || [];

                const categoryRoot = document.createElement("div");
                categoryRoot.className = "category" + (collapsedCategories.has(categoryName) ? " collapsed" : "");

                const header = document.createElement("div");
                header.className = "category-header";

                const caret = document.createElement("div");
                caret.className = "caret";
                header.appendChild(caret);

                const title = document.createElement("div");
                title.className = "category-header-title";
                title.textContent = categoryName;
                header.appendChild(title);

                header.addEventListener("click", () => {
                    if (collapsedCategories.has(categoryName)) collapsedCategories.delete(categoryName);
                    else collapsedCategories.add(categoryName);
                    render();
                });

                categoryRoot.appendChild(header);

                const rows = document.createElement("div");
                rows.className = "rows";

                for (const prop of categoryProps) {
                    const rowGroup = createRowGroup(prop);
                    rows.appendChild(rowGroup);
                }

                categoryRoot.appendChild(rows);
                container.appendChild(categoryRoot);
            }

            const tagsCategory = createTagsSection();
            container.appendChild(tagsCategory);

            const attributesCategory = createAttributesSection();
            container.appendChild(attributesCategory);
        }

        function createRowGroup(prop) {
            const group = document.createElement("div");
            group.className = "property-group";
            group.dataset.propertyName = prop.name;

            const isExpandable = isMultiValueProperty(prop.type);
            const isExpanded = expandedProperties.has(prop.name);

            if (isExpandable) {
                const mainRow = createRow(prop, true, isExpanded);
                group.appendChild(mainRow);

                if (isExpanded) {
                    const subRows = createSubRows(prop);
                    group.appendChild(subRows);
                }
            } else {
                const mainRow = createRow(prop, false, false);
                group.appendChild(mainRow);
            }

            return group;
        }

        function isMultiValueProperty(type) {
            return type === "Vector2" || type === "Vector3" || type === "UDim2" ||
                type === "CFrame" || type === "NumberRange" || type === "NumberSequence" ||
                type === "ColorSequence";
        }

        function createRow(prop, isExpandable, isExpanded) {
            const row = document.createElement("div");
            row.className = "property-row";

            const nameCell = document.createElement("div");
            nameCell.className = "property-name";

            if (isExpandable) {
                const expandButton = document.createElement("span");
                expandButton.className = "expand-button" + (isExpanded ? " expanded" : "");
                expandButton.textContent = isExpanded ? "▼" : "▶";
                expandButton.addEventListener("click", (e) => {
                    e.stopPropagation();
                    togglePropertyExpansion(prop.name);
                });
                nameCell.appendChild(expandButton);
            }

            const name = document.createElement("span");
            name.textContent = prop.name || "";
            nameCell.appendChild(name);
            row.appendChild(nameCell);

            const value = document.createElement("div");
            value.className = "property-value";
            value.appendChild(createEditor(prop, isExpandable && !isExpanded));
            row.appendChild(value);

            return row;
        }

        function createSubRows(prop) {
            const subRows = document.createElement("div");
            subRows.className = "property-subrows";

            switch (prop.type) {
                case "Vector2": {
                    if (prop.value && typeof prop.value === "object") {
                        subRows.appendChild(createSubRow(prop, "X", prop.value.X ?? 0, (val) => ({ X: val, Y: prop.value.Y ?? 0 })));
                        subRows.appendChild(createSubRow(prop, "Y", prop.value.Y ?? 0, (val) => ({ X: prop.value.X ?? 0, Y: val })));
                    } else {
                        subRows.appendChild(createSubRow(prop, "X", 0, (val) => ({ X: val, Y: 0 })));
                        subRows.appendChild(createSubRow(prop, "Y", 0, (val) => ({ X: 0, Y: val })));
                    }
                    break;
                }
                case "Vector3": {
                    if (prop.value && typeof prop.value === "object") {
                        subRows.appendChild(createSubRow(prop, "X", prop.value.X ?? 0, (val) => ({ X: val, Y: prop.value.Y ?? 0, Z: prop.value.Z ?? 0 })));
                        subRows.appendChild(createSubRow(prop, "Y", prop.value.Y ?? 0, (val) => ({ X: prop.value.X ?? 0, Y: val, Z: prop.value.Z ?? 0 })));
                        subRows.appendChild(createSubRow(prop, "Z", prop.value.Z ?? 0, (val) => ({ X: prop.value.X ?? 0, Y: prop.value.Y ?? 0, Z: val })));
                    } else {
                        subRows.appendChild(createSubRow(prop, "X", 0, (val) => ({ X: val, Y: 0, Z: 0 })));
                        subRows.appendChild(createSubRow(prop, "Y", 0, (val) => ({ X: 0, Y: val, Z: 0 })));
                        subRows.appendChild(createSubRow(prop, "Z", 0, (val) => ({ X: 0, Y: 0, Z: val })));
                    }
                    break;
                }
                case "UDim2": {
                    if (prop.value && prop.value.X && prop.value.Y) {
                        subRows.appendChild(createSubRow(prop, "X.Scale", prop.value.X.Scale ?? 0, (val) => ({ X: { Scale: val, Offset: prop.value.X.Offset ?? 0 }, Y: prop.value.Y })));
                        subRows.appendChild(createSubRow(prop, "X.Offset", prop.value.X.Offset ?? 0, (val) => ({ X: { Scale: prop.value.X.Scale ?? 0, Offset: val }, Y: prop.value.Y })));
                        subRows.appendChild(createSubRow(prop, "Y.Scale", prop.value.Y.Scale ?? 0, (val) => ({ X: prop.value.X, Y: { Scale: val, Offset: prop.value.Y.Offset ?? 0 } })));
                        subRows.appendChild(createSubRow(prop, "Y.Offset", prop.value.Y.Offset ?? 0, (val) => ({ X: prop.value.X, Y: { Scale: prop.value.Y.Scale ?? 0, Offset: val } })));
                    } else {
                        subRows.appendChild(createSubRow(prop, "X.Scale", 0, (val) => ({ X: { Scale: val, Offset: 0 }, Y: { Scale: 0, Offset: 0 } })));
                        subRows.appendChild(createSubRow(prop, "X.Offset", 0, (val) => ({ X: { Scale: 0, Offset: val }, Y: { Scale: 0, Offset: 0 } })));
                        subRows.appendChild(createSubRow(prop, "Y.Scale", 0, (val) => ({ X: { Scale: 0, Offset: 0 }, Y: { Scale: val, Offset: 0 } })));
                        subRows.appendChild(createSubRow(prop, "Y.Offset", 0, (val) => ({ X: { Scale: 0, Offset: 0 }, Y: { Scale: 0, Offset: val } })));
                    }
                    break;
                }
                case "CFrame": {
                    if (prop.value && typeof prop.value === "object" && prop.value.Position) {
                        const pos = prop.value.Position;
                        subRows.appendChild(createSubRow(prop, "Position.X", pos.X ?? 0, (val) => ({ Position: { X: val, Y: pos.Y ?? 0, Z: pos.Z ?? 0 }, Rotation: prop.value.Rotation || { X: 0, Y: 0, Z: 0 } })));
                        subRows.appendChild(createSubRow(prop, "Position.Y", pos.Y ?? 0, (val) => ({ Position: { X: pos.X ?? 0, Y: val, Z: pos.Z ?? 0 }, Rotation: prop.value.Rotation || { X: 0, Y: 0, Z: 0 } })));
                        subRows.appendChild(createSubRow(prop, "Position.Z", pos.Z ?? 0, (val) => ({ Position: { X: pos.X ?? 0, Y: pos.Y ?? 0, Z: val }, Rotation: prop.value.Rotation || { X: 0, Y: 0, Z: 0 } })));
                    } else {
                        subRows.appendChild(createSubRow(prop, "Position.X", 0, (val) => ({ Position: { X: val, Y: 0, Z: 0 }, Rotation: { X: 0, Y: 0, Z: 0 } })));
                        subRows.appendChild(createSubRow(prop, "Position.Y", 0, (val) => ({ Position: { X: 0, Y: val, Z: 0 }, Rotation: { X: 0, Y: 0, Z: 0 } })));
                        subRows.appendChild(createSubRow(prop, "Position.Z", 0, (val) => ({ Position: { X: 0, Y: 0, Z: val }, Rotation: { X: 0, Y: 0, Z: 0 } })));
                    }
                    break;
                }
                case "NumberRange": {
                    if (prop.value && typeof prop.value === "object") {
                        subRows.appendChild(createSubRow(prop, "Min", prop.value.Min ?? 0, (val) => ({ Min: val, Max: prop.value.Max ?? 0 })));
                        subRows.appendChild(createSubRow(prop, "Max", prop.value.Max ?? 0, (val) => ({ Min: prop.value.Min ?? 0, Max: val })));
                    } else {
                        subRows.appendChild(createSubRow(prop, "Min", 0, (val) => ({ Min: val, Max: 0 })));
                        subRows.appendChild(createSubRow(prop, "Max", 0, (val) => ({ Min: 0, Max: val })));
                    }
                    break;
                }
            }

            return subRows;
        }

        function createSubRow(prop, subName, currentValue, updateFn) {
            const row = document.createElement("div");
            row.className = "property-row property-subrow";

            const name = document.createElement("div");
            name.className = "property-name";
            name.textContent = subName;
            row.appendChild(name);

            const value = document.createElement("div");
            value.className = "property-value";

            const input = document.createElement("input");
            input.type = "text";
            input.className = "value-input";
            input.value = currentValue ?? "0";

            input.addEventListener("change", () => {
                const raw = (input.value || "").trim();
                const numericValue = parseFloat(raw);
                if (!Number.isFinite(numericValue)) return;
                const newValue = updateFn(numericValue);
                postSetProperty(prop.name, newValue);
            });

            value.appendChild(input);
            row.appendChild(value);

            return row;
        }

        function togglePropertyExpansion(propertyName) {
            if (expandedProperties.has(propertyName)) {
                expandedProperties.delete(propertyName);
            } else {
                expandedProperties.add(propertyName);
            }
            render();
        }

        function postSetProperty(propertyName, propertyValue) {
            vscode.postMessage({
                type: "setProperty",
                propertyName,
                propertyValue,
            });
        }

        function createEditor(prop, showCompact) {
            if (prop && prop.isInstanceReference) {
                const wrapper = document.createElement("div");
                wrapper.className = "instance-link";

                if (prop.referencedInstanceId && prop.referencedInstanceName) {
                    const link = document.createElement("a");
                    link.href = "#";
                    link.textContent = prop.referencedInstanceName;
                    link.addEventListener("click", (e) => {
                        e.preventDefault();
                        vscode.postMessage({
                            type: "navigateToInstance",
                            instanceId: prop.referencedInstanceId
                        });
                    });
                    wrapper.appendChild(link);
                } else {
                    const none = document.createElement("div");
                    none.className = "none";
                    none.textContent = "None";
                    wrapper.appendChild(none);
                }

                return wrapper;
            }

            if (prop && prop.isEnum && Array.isArray(prop.enumValues)) {
                const select = document.createElement("select");
                select.className = "value-select";

                for (const enumValue of prop.enumValues) {
                    const option = document.createElement("option");
                    option.value = String(enumValue.value);
                    option.textContent = enumValue.name;
                    if (prop.value && prop.value.Value === enumValue.value) option.selected = true;
                    select.appendChild(option);
                }

                select.addEventListener("change", () => {
                    const selectedOption = select.options[select.selectedIndex];
                    postSetProperty(prop.name, { EnumName: selectedOption.textContent, EnumType: prop.type });
                });

                return select;
            }

            switch (prop.type) {
                case "bool": {
                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.className = "value-checkbox";
                    checkbox.checked = !!prop.value;

                    checkbox.addEventListener("change", () => {
                        postSetProperty(prop.name, checkbox.checked);
                    });

                    return checkbox;
                }

                case "number":
                case "int":
                case "float":
                case "double": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    input.value = prop.value ?? "0";

                    input.addEventListener("change", () => {
                        const raw = (input.value || "").trim();
                        const numericValue = prop.type.includes("int") ? parseInt(raw, 10) : parseFloat(raw);
                        if (!Number.isFinite(numericValue)) return;
                        postSetProperty(prop.name, numericValue);
                    });

                    return input;
                }

                case "Vector2": {
                    const display = document.createElement("div");
                    display.className = "value-display";
                    if (showCompact) {
                        if (prop.value && typeof prop.value === "object") {
                            display.textContent = `${prop.value.X?.toFixed(3) ?? 0}, ${prop.value.Y?.toFixed(3) ?? 0}`;
                        } else {
                            display.textContent = "0, 0";
                        }
                    }
                    return display;
                }

                case "Vector3": {
                    const display = document.createElement("div");
                    display.className = "value-display";
                    if (showCompact) {
                        if (prop.value && typeof prop.value === "object") {
                            display.textContent = `${prop.value.X?.toFixed(3) ?? 0}, ${prop.value.Y?.toFixed(3) ?? 0}, ${prop.value.Z?.toFixed(3) ?? 0}`;
                        } else {
                            display.textContent = "0, 0, 0";
                        }
                    }
                    return display;
                }

                case "UDim2": {
                    const display = document.createElement("div");
                    display.className = "value-display";
                    if (showCompact) {
                        if (prop.value && prop.value.X && prop.value.Y) {
                            display.textContent = `${prop.value.X.Scale}, ${prop.value.X.Offset}, ${prop.value.Y.Scale}, ${prop.value.Y.Offset}`;
                        } else {
                            display.textContent = "0, 0, 0, 0";
                        }
                    }
                    return display;
                }

                case "CFrame": {
                    const display = document.createElement("div");
                    display.className = "value-display";
                    if (showCompact) {
                        if (prop.value && typeof prop.value === "object" && prop.value.Position) {
                            const pos = prop.value.Position;
                            display.textContent = `${pos.X?.toFixed(3) ?? 0}, ${pos.Y?.toFixed(3) ?? 0}, ${pos.Z?.toFixed(3) ?? 0}`;
                        } else {
                            display.textContent = "0, 0, 0";
                        }
                    }
                    return display;
                }

                case "NumberRange": {
                    const display = document.createElement("div");
                    display.className = "value-display";
                    if (showCompact) {
                        if (prop.value && typeof prop.value === "object") {
                            display.textContent = `${prop.value.Min ?? 0} - ${prop.value.Max ?? 0}`;
                        } else {
                            display.textContent = "0 - 0";
                        }
                    } else {
                        display.textContent = "Click to expand";
                    }
                    return display;
                }

                case "NumberSequence": {
                    const wrapper = document.createElement("div");
                    wrapper.className = "sequence-wrapper";

                    const display = document.createElement("div");
                    display.className = "value-display sequence-display";
                    if (prop.value && Array.isArray(prop.value.Keypoints)) {
                        const keypoints = prop.value.Keypoints;
                        display.textContent = `${keypoints.length} keypoint${keypoints.length !== 1 ? 's' : ''}`;
                    } else {
                        display.textContent = "0 keypoints";
                    }

                    const button = document.createElement("button");
                    button.className = "sequence-button";
                    button.textContent = "Edit";
                    button.addEventListener("click", () => {
                        openCurveEditor(prop);
                    });

                    wrapper.appendChild(display);
                    wrapper.appendChild(button);
                    return wrapper;
                }

                case "ColorSequence": {
                    const wrapper = document.createElement("div");
                    wrapper.className = "sequence-wrapper";

                    const display = document.createElement("div");
                    display.className = "value-display sequence-display";
                    if (prop.value && Array.isArray(prop.value.Keypoints)) {
                        const keypoints = prop.value.Keypoints;
                        display.textContent = `${keypoints.length} keypoint${keypoints.length !== 1 ? 's' : ''}`;
                    } else {
                        display.textContent = "0 keypoints";
                    }

                    const button = document.createElement("button");
                    button.className = "sequence-button";
                    button.textContent = "Edit";
                    button.addEventListener("click", () => {
                        openColorSequenceEditor(prop);
                    });

                    wrapper.appendChild(display);
                    wrapper.appendChild(button);
                    return wrapper;
                }

                case "Color3": {
                    const input = document.createElement("input");
                    input.type = "color";
                    input.className = "value-input";
                    input.style.padding = "0";
                    input.style.height = "18px";

                    if (prop.value && typeof prop.value === "object") {
                        const r = Math.max(0, Math.min(255, Math.round((prop.value.R ?? 0) * 255)));
                        const g = Math.max(0, Math.min(255, Math.round((prop.value.G ?? 0) * 255)));
                        const b = Math.max(0, Math.min(255, Math.round((prop.value.B ?? 0) * 255)));
                        input.value = `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
                    } else {
                        input.value = "#000000";
                    }

                    input.addEventListener("change", () => {
                        const r = parseInt(input.value.slice(1, 3), 16) / 255;
                        const g = parseInt(input.value.slice(3, 5), 16) / 255;
                        const b = parseInt(input.value.slice(5, 7), 16) / 255;
                        postSetProperty(prop.name, { R: r, G: g, B: b });
                    });

                    return input;
                }

                case "ContentId":
                case "string": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    input.value = prop.value ?? "";

                    input.addEventListener("change", () => {
                        postSetProperty(prop.name, input.value);
                    });

                    return input;
                }

                default: {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    input.value = prop.value != null ? String(prop.value) : "";

                    input.addEventListener("change", () => {
                        const raw = input.value;
                        try {
                            postSetProperty(prop.name, JSON.parse(raw));
                        } catch {
                            postSetProperty(prop.name, raw);
                        }
                    });

                    return input;
                }
            }
        }

        function openCurveEditor(prop) {
            currentCurveProperty = prop;
            const modal = document.getElementById("curve-editor-modal");
            const title = document.getElementById("curve-editor-title");
            title.textContent = `Edit ${prop.name} (NumberSequence)`;

            if (prop.value && Array.isArray(prop.value.Keypoints) && prop.value.Keypoints.length > 0) {
                currentCurveNodes = prop.value.Keypoints.map(kp => ({
                    t: kp.Time ?? 0,
                    v: kp.Value ?? 0
                })).sort((a, b) => a.t - b.t);

                if (currentCurveNodes[0].t !== 0) {
                    currentCurveNodes.unshift({ t: 0, v: currentCurveNodes[0].v });
                }
                const lastIdx = currentCurveNodes.length - 1;
                if (currentCurveNodes[lastIdx].t !== 1) {
                    currentCurveNodes.push({ t: 1, v: currentCurveNodes[lastIdx].v });
                }
            } else {
                currentCurveNodes = [{ t: 0, v: 0 }, { t: 1, v: 0 }];
            }

            curveCanvas = document.getElementById("curve-canvas");
            curveCtx = curveCanvas.getContext("2d");
            selectedNodeIndex = -1;
            draggingNodeIndex = -1;

            setupCurveCanvasListeners();
            updateCurveEditor();
            modal.style.display = "flex";
        }

        function openColorSequenceEditor(prop) {
            try {
                currentGradientProperty = prop;
                const modal = document.getElementById("gradient-editor-modal");
                if (!modal) {
                    console.error("Gradient editor modal not found");
                    return;
                }
                const title = document.getElementById("gradient-editor-title");
                if (title) {
                    title.textContent = `Edit ${prop.name} (ColorSequence)`;
                }

                if (prop.value && Array.isArray(prop.value.Keypoints)) {
                    currentGradientStops = prop.value.Keypoints.map(kp => {
                        let color = { r: 0, g: 0, b: 0 };
                        if (kp.Value) {
                            if (typeof kp.Value === "object" && kp.Value.R !== undefined) {
                                color = {
                                    r: Math.round(kp.Value.R * 255),
                                    g: Math.round(kp.Value.G * 255),
                                    b: Math.round(kp.Value.B * 255)
                                };
                            }
                        }
                        return {
                            time: kp.Time ?? 0,
                            color: color
                        };
                    }).sort((a, b) => a.time - b.time);
                } else {
                    currentGradientStops = [
                        { time: 0, color: { r: 0, g: 0, b: 0 } },
                        { time: 1, color: { r: 255, g: 255, b: 255 } }
                    ];
                }

                selectedGradientStopIndex = -1;
                draggingGradientStopIndex = -1;

                updateGradientEditor();
                modal.style.display = "flex";
            } catch (error) {
                console.error("Error opening color sequence editor:", error);
            }
        }

        function updateGradientEditor() {
            const preview = document.getElementById("gradient-preview");
            const stopsContainer = document.getElementById("gradient-stops");
            const stopsList = document.getElementById("gradient-stops-list");

            if (!preview || !stopsContainer || !stopsList) return;

            const sortedStops = [...currentGradientStops].sort((a, b) => a.time - b.time);

            let gradientStops = sortedStops.map(stop => {
                const percent = stop.time * 100;
                return `${rgbToHex(stop.color)} ${percent}%`;
            }).join(", ");

            preview.style.background = `linear-gradient(to right, ${gradientStops})`;

            stopsContainer.innerHTML = "";
            for (let i = 0; i < sortedStops.length; i++) {
                const stop = sortedStops[i];
                const idx = currentGradientStops.indexOf(stop);
                const stopElement = document.createElement("div");
                stopElement.className = "gradient-stop-handle" + (selectedGradientStopIndex === idx ? " selected" : "");
                stopElement.style.left = `${stop.time * 100}%`;
                stopElement.dataset.index = idx.toString();

                stopElement.addEventListener("mousedown", (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    draggingGradientStopIndex = idx;
                    selectedGradientStopIndex = idx;
                    updateGradientEditor();
                });

                stopsContainer.appendChild(stopElement);
            }

            stopsList.innerHTML = "";
            for (let i = 0; i < sortedStops.length; i++) {
                const stop = sortedStops[i];
                const idx = currentGradientStops.indexOf(stop);
                const item = document.createElement("div");
                item.className = "gradient-stop-item" + (selectedGradientStopIndex === idx ? " selected" : "");

                const timeInput = document.createElement("input");
                timeInput.type = "number";
                timeInput.className = "curve-node-input";
                timeInput.min = "0";
                timeInput.max = "1";
                timeInput.step = "0.01";
                timeInput.value = stop.time.toFixed(2);
                timeInput.addEventListener("change", () => {
                    const val = parseFloat(timeInput.value);
                    if (!isNaN(val)) {
                        stop.time = Math.max(0, Math.min(1, val));
                        updateGradientEditor();
                    }
                });

                const colorInput = document.createElement("input");
                colorInput.type = "color";
                colorInput.className = "gradient-color-input";
                colorInput.value = rgbToHex(stop.color);
                colorInput.addEventListener("change", () => {
                    const hex = colorInput.value;
                    stop.color = hexToRgb(hex);
                    updateGradientEditor();
                });

                const deleteBtn = document.createElement("button");
                deleteBtn.className = "curve-node-delete";
                deleteBtn.textContent = "×";
                deleteBtn.addEventListener("click", () => {
                    if (currentGradientStops.length > 2) {
                        currentGradientStops.splice(idx, 1);
                        selectedGradientStopIndex = -1;
                        updateGradientEditor();
                    }
                });

                item.appendChild(document.createTextNode("Time: "));
                item.appendChild(timeInput);
                item.appendChild(document.createTextNode(" Color: "));
                item.appendChild(colorInput);
                if (currentGradientStops.length > 2) {
                    item.appendChild(deleteBtn);
                }

                item.addEventListener("click", (e) => {
                    if (e.target !== deleteBtn && e.target !== timeInput && e.target !== colorInput) {
                        selectedGradientStopIndex = idx;
                        updateGradientEditor();
                    }
                });

                stopsList.appendChild(item);
            }
        }

        function rgbToHex(rgb) {
            return "#" + [rgb.r, rgb.g, rgb.b].map(x => {
                const hex = Math.round(x).toString(16);
                return hex.length === 1 ? "0" + hex : hex;
            }).join("");
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function applyGradientEditor() {
            if (!currentGradientProperty) return;

            const keypoints = currentGradientStops.map(stop => ({
                Time: stop.time,
                Value: {
                    R: stop.color.r / 255,
                    G: stop.color.g / 255,
                    B: stop.color.b / 255
                }
            }));

            postSetProperty(currentGradientProperty.name, { Keypoints: keypoints });
            closeGradientEditor();
        }

        function closeGradientEditor() {
            const modal = document.getElementById("gradient-editor-modal");
            if (modal) {
                modal.style.display = "none";
            }
            currentGradientProperty = null;
            currentGradientStops = [];
            selectedGradientStopIndex = -1;
            draggingGradientStopIndex = -1;
        }

        function updateCurveEditor() {
            if (!curveCanvas || !curveCtx) return;

            const width = curveCanvas.width;
            const height = curveCanvas.height;
            const padding = 30;

            curveCtx.clearRect(0, 0, width, height);
            curveCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-background') || '#1e1e1e';
            curveCtx.fillRect(0, 0, width, height);

            const drawWidth = width - padding * 2;
            const drawHeight = height - padding * 2;

            curveCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--vscode-panel-border') || '#3e3e3e';
            curveCtx.lineWidth = 1;

            for (let i = 0; i <= 10; i++) {
                const x = padding + (drawWidth / 10) * i;
                curveCtx.beginPath();
                curveCtx.moveTo(x, padding);
                curveCtx.lineTo(x, height - padding);
                curveCtx.stroke();

                const y = padding + (drawHeight / 10) * i;
                curveCtx.beginPath();
                curveCtx.moveTo(padding, y);
                curveCtx.lineTo(width - padding, y);
                curveCtx.stroke();
            }

            if (currentCurveNodes.length > 0) {
                const sortedIndices = currentCurveNodes.map((_, i) => i).sort((a, b) => currentCurveNodes[a].t - currentCurveNodes[b].t);

                curveCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--vscode-textLink-foreground') || '#4fc3f7';
                curveCtx.lineWidth = 2;
                curveCtx.beginPath();

                for (let i = 0; i < sortedIndices.length; i++) {
                    const idx = sortedIndices[i];
                    const node = currentCurveNodes[idx];
                    const x = padding + node.t * drawWidth;
                    const y = height - padding - node.v * drawHeight;

                    if (i === 0) {
                        curveCtx.moveTo(x, y);
                    } else {
                        curveCtx.lineTo(x, y);
                    }
                }

                curveCtx.stroke();

                for (let i = 0; i < sortedIndices.length; i++) {
                    const idx = sortedIndices[i];
                    const node = currentCurveNodes[idx];
                    const x = padding + node.t * drawWidth;
                    const y = height - padding - node.v * drawHeight;

                    const isSelected = selectedNodeIndex === idx;
                    const nodeRadius = 7;

                    curveCtx.fillStyle = isSelected ? '#ff6b6b' : '#4fc3f7';
                    curveCtx.beginPath();
                    curveCtx.arc(x, y, nodeRadius, 0, Math.PI * 2);
                    curveCtx.fill();

                    if (isSelected) {
                        curveCtx.strokeStyle = '#ff6b6b';
                        curveCtx.lineWidth = 2;
                        curveCtx.stroke();
                    }
                }
            }

            updateCurveNodesList();
        }

        function updateCurveNodesList() {
            const list = document.getElementById("curve-nodes-list");
            list.innerHTML = "";

            const sortedIndices = currentCurveNodes.map((_, i) => i).sort((a, b) => currentCurveNodes[a].t - currentCurveNodes[b].t);

            for (const idx of sortedIndices) {
                const node = currentCurveNodes[idx];
                const item = document.createElement("div");
                item.className = "curve-node-item" + (selectedNodeIndex === idx ? " selected" : "");

                const sortedIndices = currentCurveNodes.map((_, i) => i).sort((a, b) => currentCurveNodes[a].t - currentCurveNodes[b].t);
                const isFirst = sortedIndices[0] === idx;
                const isLast = sortedIndices[sortedIndices.length - 1] === idx;

                const tInput = document.createElement("input");
                tInput.type = "number";
                tInput.className = "curve-node-input";
                tInput.min = "0";
                tInput.max = "1";
                tInput.step = "0.01";
                tInput.value = node.t.toFixed(2);
                tInput.disabled = isFirst || isLast;
                if (isFirst || isLast) {
                    tInput.title = isFirst ? "First node must stay at t=0" : "Last node must stay at t=1";
                }
                tInput.addEventListener("change", () => {
                    if (isFirst || isLast) return;
                    const val = parseFloat(tInput.value);
                    if (!isNaN(val)) {
                        node.t = Math.max(0, Math.min(1, val));
                        updateCurveEditor();
                    }
                });

                const vInput = document.createElement("input");
                vInput.type = "number";
                vInput.className = "curve-node-input";
                vInput.min = "0";
                vInput.max = "1";
                vInput.step = "0.01";
                vInput.value = node.v.toFixed(2);
                vInput.addEventListener("change", () => {
                    const val = parseFloat(vInput.value);
                    if (!isNaN(val)) {
                        node.v = Math.max(0, Math.min(1, val));
                        updateCurveEditor();
                    }
                });

                const sortedIndicesForDelete = currentCurveNodes.map((_, i) => i).sort((a, b) => currentCurveNodes[a].t - currentCurveNodes[b].t);
                const isFirstForDelete = sortedIndicesForDelete[0] === idx;
                const isLastForDelete = sortedIndicesForDelete[sortedIndicesForDelete.length - 1] === idx;

                const deleteBtn = document.createElement("button");
                deleteBtn.className = "curve-node-delete";
                deleteBtn.textContent = "×";
                deleteBtn.disabled = isFirstForDelete || isLastForDelete;
                if (isFirstForDelete || isLastForDelete) {
                    deleteBtn.title = "Cannot delete first or last node";
                }
                deleteBtn.addEventListener("click", () => {
                    if (currentCurveNodes.length > 2 && !isFirstForDelete && !isLastForDelete) {
                        currentCurveNodes.splice(idx, 1);
                        selectedNodeIndex = -1;
                        updateCurveEditor();
                    }
                });

                item.appendChild(document.createTextNode("T: "));
                item.appendChild(tInput);
                item.appendChild(document.createTextNode(" V: "));
                item.appendChild(vInput);
                item.appendChild(deleteBtn);

                item.addEventListener("click", (e) => {
                    if (e.target !== deleteBtn && e.target !== tInput && e.target !== vInput) {
                        selectedNodeIndex = idx;
                        updateCurveEditor();
                    }
                });

                list.appendChild(item);
            }
        }

        function addCurveNode() {
            currentCurveNodes.push({ t: 0.5, v: 0.5 });
            selectedNodeIndex = currentCurveNodes.length - 1;
            updateCurveEditor();
        }

        function applyCurveEditor() {
            if (!currentCurveProperty) return;

            const sortedNodes = [...currentCurveNodes].sort((a, b) => a.t - b.t);

            if (sortedNodes.length === 0) {
                sortedNodes.push({ t: 0, v: 0 }, { t: 1, v: 0 });
            } else {
                if (sortedNodes[0].t !== 0) {
                    sortedNodes.unshift({ t: 0, v: sortedNodes[0].v });
                }
                const lastIdx = sortedNodes.length - 1;
                if (sortedNodes[lastIdx].t !== 1) {
                    sortedNodes.push({ t: 1, v: sortedNodes[lastIdx].v });
                }
            }

            const keypoints = sortedNodes.map(node => ({
                Time: node.t,
                Value: node.v
            }));

            postSetProperty(currentCurveProperty.name, { Keypoints: keypoints });
            closeCurveEditor();
        }

        function closeCurveEditor() {
            const modal = document.getElementById("curve-editor-modal");
            modal.style.display = "none";
            currentCurveProperty = null;
            currentCurveNodes = [];
            selectedNodeIndex = -1;
            draggingNodeIndex = -1;
        }

        function setupCurveCanvasListeners() {
            curveCanvas = document.getElementById("curve-canvas");
            if (!curveCanvas) return;

            curveCanvas.addEventListener("mousedown", (e) => {
                if (!curveCanvas || !curveCtx) return;

                const rect = curveCanvas.getBoundingClientRect();
                const scaleX = curveCanvas.width / rect.width;
                const scaleY = curveCanvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                const padding = 30;
                const drawWidth = curveCanvas.width - padding * 2;
                const drawHeight = curveCanvas.height - padding * 2;

                let closestIdx = -1;
                let closestDist = Infinity;

                const sortedIndices = currentCurveNodes.map((_, i) => i).sort((a, b) => currentCurveNodes[a].t - currentCurveNodes[b].t);

                for (let i = 0; i < currentCurveNodes.length; i++) {
                    const node = currentCurveNodes[i];
                    const nodeX = padding + node.t * drawWidth;
                    const nodeY = curveCanvas.height - padding - node.v * drawHeight;
                    const dist = Math.sqrt(Math.pow(x - nodeX, 2) + Math.pow(y - nodeY, 2));

                    const hitRadius = 14;

                    if (dist < hitRadius && dist < closestDist) {
                        closestDist = dist;
                        closestIdx = i;
                    }
                }

                if (closestIdx >= 0) {
                    draggingNodeIndex = closestIdx;
                    selectedNodeIndex = closestIdx;
                    updateCurveEditor();
                } else {
                    const t = Math.max(0, Math.min(1, (x - padding) / drawWidth));
                    const v = Math.max(0, Math.min(1, (curveCanvas.height - padding - y) / drawHeight));
                    currentCurveNodes.push({ t, v });
                    selectedNodeIndex = currentCurveNodes.length - 1;
                    updateCurveEditor();
                }
            });

            curveCanvas.addEventListener("mousemove", (e) => {
                if (draggingNodeIndex >= 0 && draggingNodeIndex < currentCurveNodes.length && curveCanvas) {
                    const rect = curveCanvas.getBoundingClientRect();
                    const scaleX = curveCanvas.width / rect.width;
                    const scaleY = curveCanvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    const padding = 30;
                    const drawWidth = curveCanvas.width - padding * 2;
                    const drawHeight = curveCanvas.height - padding * 2;

                    const v = Math.max(0, Math.min(1, (curveCanvas.height - padding - y) / drawHeight));
                    currentCurveNodes[draggingNodeIndex].v = v;

                    const sortedIndices = currentCurveNodes.map((_, i) => i).sort((a, b) => currentCurveNodes[a].t - currentCurveNodes[b].t);
                    const isFirst = sortedIndices[0] === draggingNodeIndex;
                    const isLast = sortedIndices[sortedIndices.length - 1] === draggingNodeIndex;

                    if (!isFirst && !isLast) {
                        const t = Math.max(0, Math.min(1, (x - padding) / drawWidth));
                        currentCurveNodes[draggingNodeIndex].t = t;
                    } else {
                        if (isFirst) {
                            currentCurveNodes[draggingNodeIndex].t = 0;
                        } else if (isLast) {
                            currentCurveNodes[draggingNodeIndex].t = 1;
                        }
                    }

                    updateCurveEditor();
                }
            });

            curveCanvas.addEventListener("mouseup", () => {
                draggingNodeIndex = -1;
            });

            curveCanvas.addEventListener("mouseleave", () => {
                draggingNodeIndex = -1;
            });
        }

        document.getElementById("curve-editor-modal")?.addEventListener("click", (e) => {
            if (e.target.id === "curve-editor-modal") {
                closeCurveEditor();
            }
        });

        document.getElementById("gradient-editor-modal")?.addEventListener("click", (e) => {
            if (e.target.id === "gradient-editor-modal") {
                closeGradientEditor();
            }
        });

        const gradientPreviewContainer = document.getElementById("gradient-preview-container");
        if (gradientPreviewContainer) {
            const preview = document.getElementById("gradient-preview");

            if (preview) {
                preview.addEventListener("mousedown", (e) => {
                    if (draggingGradientStopIndex >= 0) return;

                    const rect = preview.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const time = Math.max(0, Math.min(1, x / rect.width));

                    const newStop = {
                        time: time,
                        color: { r: 128, g: 128, b: 128 }
                    };
                    currentGradientStops.push(newStop);
                    selectedGradientStopIndex = currentGradientStops.length - 1;
                    updateGradientEditor();
                });
            }

            document.addEventListener("mousemove", (e) => {
                if (draggingGradientStopIndex >= 0 && draggingGradientStopIndex < currentGradientStops.length) {
                    const preview = document.getElementById("gradient-preview");
                    if (!preview) return;

                    const rect = preview.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const time = Math.max(0, Math.min(1, x / rect.width));

                    currentGradientStops[draggingGradientStopIndex].time = time;
                    updateGradientEditor();
                }
            });

            document.addEventListener("mouseup", () => {
                draggingGradientStopIndex = -1;
            });
        }

        function createTagsSection() {
            const categoryRoot = document.createElement("div");
            categoryRoot.className = "category" + (collapsedCategories.has("Tags") ? " collapsed" : "");

            const header = document.createElement("div");
            header.className = "category-header";

            const caret = document.createElement("div");
            caret.className = "caret";
            header.appendChild(caret);

            const title = document.createElement("div");
            title.className = "category-header-title";
            title.textContent = "Tags";
            header.appendChild(title);

            const addButton = document.createElement("button");
            addButton.className = "add-button";
            addButton.textContent = "+";
            addButton.title = "Add Tag";
            addButton.addEventListener("click", (e) => {
                e.stopPropagation();
                showTagInput = !showTagInput;
                render();
            });
            header.appendChild(addButton);

            header.addEventListener("click", (e) => {
                if (e.target !== addButton) {
                    if (collapsedCategories.has("Tags")) collapsedCategories.delete("Tags");
                    else collapsedCategories.add("Tags");
                    render();
                }
            });

            categoryRoot.appendChild(header);

            const rows = document.createElement("div");
            rows.className = "rows";

            if (showTagInput) {
                const inputWrapper = document.createElement("div");
                inputWrapper.className = "tag-input-wrapper";
                const input = document.createElement("input");
                input.type = "text";
                input.className = "tag-input";
                input.placeholder = "Enter tag name...";
                input.addEventListener("keydown", (e) => {
                    if (e.key === "Enter") {
                        const tagName = input.value.trim();
                        if (tagName) {
                            vscode.postMessage({
                                type: "addTag",
                                tagName
                            });
                            showTagInput = false;
                        }
                    } else if (e.key === "Escape") {
                        showTagInput = false;
                        render();
                    }
                });
                inputWrapper.appendChild(input);
                rows.appendChild(inputWrapper);
                setTimeout(() => input.focus(), 10);
            }

            const tagsContainer = document.createElement("div");
            tagsContainer.className = "tags-container";

            if (allTags.length === 0 && !showTagInput) {
                const empty = document.createElement("div");
                empty.className = "empty";
                empty.textContent = "No tags";
                empty.style.padding = "4px 0";
                tagsContainer.appendChild(empty);
            } else {
                for (const tag of allTags) {
                    const tagItem = document.createElement("div");
                    tagItem.className = "tag-item";

                    const tagText = document.createElement("span");
                    tagText.textContent = tag;
                    tagItem.appendChild(tagText);

                    const removeBtn = document.createElement("span");
                    removeBtn.className = "tag-item-remove";
                    removeBtn.textContent = "×";
                    removeBtn.addEventListener("click", () => {
                        vscode.postMessage({
                            type: "removeTag",
                            tagName: tag
                        });
                    });
                    tagItem.appendChild(removeBtn);

                    tagsContainer.appendChild(tagItem);
                }
            }

            rows.appendChild(tagsContainer);
            categoryRoot.appendChild(rows);

            return categoryRoot;
        }

        function createAttributesSection() {
            const categoryRoot = document.createElement("div");
            categoryRoot.className = "category" + (collapsedCategories.has("Attributes") ? " collapsed" : "");

            const header = document.createElement("div");
            header.className = "category-header";

            const caret = document.createElement("div");
            caret.className = "caret";
            header.appendChild(caret);

            const title = document.createElement("div");
            title.className = "category-header-title";
            title.textContent = "Attributes";
            header.appendChild(title);

            const addButton = document.createElement("button");
            addButton.className = "add-button";
            addButton.textContent = "+";
            addButton.title = "Add Attribute";
            addButton.addEventListener("click", (e) => {
                e.stopPropagation();
                openAttributeModal();
            });
            header.appendChild(addButton);

            header.addEventListener("click", (e) => {
                if (e.target !== addButton) {
                    if (collapsedCategories.has("Attributes")) collapsedCategories.delete("Attributes");
                    else collapsedCategories.add("Attributes");
                    render();
                }
            });

            categoryRoot.appendChild(header);

            const rows = document.createElement("div");
            rows.className = "rows";

            if (allAttributes.length === 0) {
                const empty = document.createElement("div");
                empty.className = "empty";
                empty.textContent = "No attributes";
                rows.appendChild(empty);
            } else {
                for (const attr of allAttributes) {
                    const row = createAttributeRow(attr);
                    rows.appendChild(row);
                }
            }

            categoryRoot.appendChild(rows);

            return categoryRoot;
        }

        function createAttributeRow(attr) {
            const row = document.createElement("div");
            row.className = "attribute-row";

            const nameCell = document.createElement("div");
            nameCell.className = "attribute-name";

            if (renamingAttribute === attr.name) {
                const nameInput = document.createElement("input");
                nameInput.type = "text";
                nameInput.className = "attribute-name-input";
                nameInput.value = attr.name;
                nameInput.addEventListener("keydown", (e) => {
                    if (e.key === "Enter") {
                        const newName = nameInput.value.trim();
                        if (newName && newName !== attr.name) {
                            vscode.postMessage({
                                type: "renameAttribute",
                                oldName: attr.name,
                                newName: newName
                            });
                        }
                        renamingAttribute = null;
                        render();
                    } else if (e.key === "Escape") {
                        renamingAttribute = null;
                        render();
                    }
                });
                nameInput.addEventListener("blur", () => {
                    renamingAttribute = null;
                    render();
                });
                nameCell.appendChild(nameInput);
                setTimeout(() => {
                    nameInput.focus();
                    nameInput.select();
                }, 10);
            } else {
                const nameText = document.createElement("span");
                nameText.className = "attribute-name-text";
                nameText.textContent = attr.name;
                nameCell.appendChild(nameText);
            }

            row.appendChild(nameCell);

            const valueCell = document.createElement("div");
            valueCell.className = "attribute-value";
            valueCell.appendChild(createAttributeEditor(attr));
            row.appendChild(valueCell);

            const gearCell = document.createElement("div");
            gearCell.className = "attribute-gear";
            gearCell.textContent = "⚙";
            gearCell.title = "Options";
            gearCell.addEventListener("click", (e) => {
                e.preventDefault();
                e.stopPropagation();
                showAttributeContextMenu(e, attr.name, gearCell);
            });
            gearCell.addEventListener("mousedown", (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
            row.appendChild(gearCell);

            return row;
        }

        function showAttributeContextMenu(event, attributeName, gearElement) {
            closeAttributeContextMenu();

            const menu = document.createElement("div");
            menu.className = "attribute-context-menu";

            const renameItem = document.createElement("div");
            renameItem.className = "attribute-context-item";
            renameItem.textContent = "Rename";
            renameItem.addEventListener("click", (e) => {
                e.stopPropagation();
                e.preventDefault();
                renamingAttribute = attributeName;
                closeAttributeContextMenu();
                render();
            });
            menu.appendChild(renameItem);

            const removeItem = document.createElement("div");
            removeItem.className = "attribute-context-item";
            removeItem.textContent = "Delete";
            removeItem.addEventListener("click", (e) => {
                e.stopPropagation();
                e.preventDefault();
                vscode.postMessage({
                    type: "removeAttribute",
                    attributeName: attributeName
                });
                closeAttributeContextMenu();
            });
            menu.appendChild(removeItem);

            document.body.appendChild(menu);
            currentContextMenu = menu;

            const gearRect = gearElement.getBoundingClientRect();
            const menuRect = menu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            menu.style.position = "fixed";

            // align bottom-right of menu with bottom-right of gear icon
            let left = gearRect.right - menuRect.width;
            let top = gearRect.bottom - menuRect.height - 2;

            // prevent overflow - adjust if menu would go off screen
            if (left < 4) {
                left = gearRect.left;
            }
            if (top < 4) {
                top = gearRect.bottom + 2;
            }
            if (left + menuRect.width > viewportWidth - 4) {
                left = viewportWidth - menuRect.width - 4;
            }
            if (top + menuRect.height > viewportHeight - 4) {
                top = viewportHeight - menuRect.height - 4;
            }

            menu.style.left = `${left}px`;
            menu.style.top = `${top}px`;

            setTimeout(() => {
                const closeHandler = (e) => {
                    const target = e.target;
                    if (menu.contains(target) ||
                        target === gearElement ||
                        target.tagName === "INPUT" ||
                        target.tagName === "SELECT" ||
                        target.closest("input") ||
                        target.closest("select") ||
                        target.closest(".attribute-context-menu")) {
                        return;
                    }
                    closeAttributeContextMenu();
                    document.removeEventListener("mousedown", closeHandler);
                    document.removeEventListener("click", closeHandler);
                };
                menu.addEventListener("click", (e) => {
                    e.stopPropagation();
                });
                document.addEventListener("mousedown", closeHandler, true);
                document.addEventListener("click", closeHandler, true);
            }, 0);
        }

        function closeAttributeContextMenu() {
            if (currentContextMenu) {
                currentContextMenu.remove();
                currentContextMenu = null;
            }
        }

        function createAttributeEditor(attr) {
            const type = attr.type;

            switch (type) {
                case "boolean": {
                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.className = "value-checkbox";
                    checkbox.checked = !!attr.value;
                    checkbox.addEventListener("change", () => {
                        postSetAttribute(attr.name, checkbox.checked);
                    });
                    return checkbox;
                }

                case "number": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    input.value = attr.value ?? "0";
                    input.addEventListener("change", () => {
                        const numericValue = parseFloat(input.value);
                        if (Number.isFinite(numericValue)) {
                            postSetAttribute(attr.name, numericValue);
                        }
                    });
                    return input;
                }

                case "Vector2": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    if (attr.value && typeof attr.value === "object") {
                        input.value = `${attr.value.X ?? 0}, ${attr.value.Y ?? 0}`;
                    } else {
                        input.value = "0, 0";
                    }
                    input.addEventListener("change", () => {
                        const parts = input.value.split(",").map(s => parseFloat(s.trim()));
                        if (parts.length >= 2 && parts.every(n => Number.isFinite(n))) {
                            postSetAttribute(attr.name, { X: parts[0], Y: parts[1] });
                        }
                    });
                    return input;
                }

                case "Vector3": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    if (attr.value && typeof attr.value === "object") {
                        input.value = `${attr.value.X ?? 0}, ${attr.value.Y ?? 0}, ${attr.value.Z ?? 0}`;
                    } else {
                        input.value = "0, 0, 0";
                    }
                    input.addEventListener("change", () => {
                        const parts = input.value.split(",").map(s => parseFloat(s.trim()));
                        if (parts.length >= 3 && parts.every(n => Number.isFinite(n))) {
                            postSetAttribute(attr.name, { X: parts[0], Y: parts[1], Z: parts[2] });
                        }
                    });
                    return input;
                }

                case "UDim": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    if (attr.value && typeof attr.value === "object") {
                        input.value = `${attr.value.Scale ?? 0}, ${attr.value.Offset ?? 0}`;
                    } else {
                        input.value = "0, 0";
                    }
                    input.addEventListener("change", () => {
                        const parts = input.value.split(",").map(s => parseFloat(s.trim()));
                        if (parts.length >= 2 && parts.every(n => Number.isFinite(n))) {
                            postSetAttribute(attr.name, { Scale: parts[0], Offset: parts[1] });
                        }
                    });
                    return input;
                }

                case "UDim2": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    if (attr.value && attr.value.X && attr.value.Y) {
                        input.value = `${attr.value.X.Scale ?? 0}, ${attr.value.X.Offset ?? 0}, ${attr.value.Y.Scale ?? 0}, ${attr.value.Y.Offset ?? 0}`;
                    } else {
                        input.value = "0, 0, 0, 0";
                    }
                    input.addEventListener("change", () => {
                        const parts = input.value.split(",").map(s => parseFloat(s.trim()));
                        if (parts.length >= 4 && parts.every(n => Number.isFinite(n))) {
                            postSetAttribute(attr.name, {
                                X: { Scale: parts[0], Offset: parts[1] },
                                Y: { Scale: parts[2], Offset: parts[3] }
                            });
                        }
                    });
                    return input;
                }

                case "Color3": {
                    const input = document.createElement("input");
                    input.type = "color";
                    input.className = "value-input";
                    input.style.padding = "0";
                    input.style.height = "18px";

                    if (attr.value && typeof attr.value === "object") {
                        const r = Math.max(0, Math.min(255, Math.round((attr.value.R ?? 0) * 255)));
                        const g = Math.max(0, Math.min(255, Math.round((attr.value.G ?? 0) * 255)));
                        const b = Math.max(0, Math.min(255, Math.round((attr.value.B ?? 0) * 255)));
                        input.value = `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
                    } else {
                        input.value = "#ffffff";
                    }

                    const updateColor = () => {
                        const r = parseInt(input.value.slice(1, 3), 16) / 255;
                        const g = parseInt(input.value.slice(3, 5), 16) / 255;
                        const b = parseInt(input.value.slice(5, 7), 16) / 255;
                        postSetAttribute(attr.name, { R: r, G: g, B: b });
                    };
                    input.addEventListener("change", updateColor);
                    return input;
                }

                case "NumberRange": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    if (attr.value && typeof attr.value === "object") {
                        input.value = `${attr.value.Min ?? 0}, ${attr.value.Max ?? 0}`;
                    } else {
                        input.value = "0, 0";
                    }
                    input.addEventListener("change", () => {
                        const parts = input.value.split(",").map(s => parseFloat(s.trim()));
                        if (parts.length >= 2 && parts.every(n => Number.isFinite(n))) {
                            postSetAttribute(attr.name, { Min: parts[0], Max: parts[1] });
                        }
                    });
                    return input;
                }

                case "string": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    input.value = attr.value ?? "";
                    input.addEventListener("change", () => {
                        postSetAttribute(attr.name, input.value);
                    });
                    return input;
                }

                default: {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    input.value = attr.value != null ? String(attr.value) : "";
                    input.addEventListener("change", () => {
                        postSetAttribute(attr.name, input.value);
                    });
                    return input;
                }
            }
        }

        function postSetAttribute(attributeName, attributeValue) {
            vscode.postMessage({
                type: "setAttribute",
                attributeName,
                attributeValue
            });
        }

        function openAttributeModal() {
            const modal = document.getElementById("attribute-modal");
            if (!modal) {
                createAttributeModal();
            }
            const modalElement = document.getElementById("attribute-modal");
            modalElement.style.display = "flex";

            const nameInput = document.getElementById("attribute-name-input");
            if (nameInput) {
                nameInput.value = "";
                setTimeout(() => nameInput.focus(), 10);
            }

            const typeSelect = document.getElementById("attribute-type-select");
            if (typeSelect) {
                typeSelect.selectedIndex = 0;
            }

            updateCharCounter();
        }

        function closeAttributeModal() {
            const modal = document.getElementById("attribute-modal");
            if (modal) {
                modal.style.display = "none";
            }
        }

        function createAttributeModal() {
            const modal = document.createElement("div");
            modal.id = "attribute-modal";
            modal.className = "attribute-modal";
            modal.style.display = "none";

            const content = document.createElement("div");
            content.className = "attribute-modal-content";

            const body = document.createElement("div");
            body.className = "attribute-modal-body";

            const nameField = document.createElement("div");
            nameField.className = "attribute-modal-field";
            const nameLabel = document.createElement("label");
            nameLabel.className = "attribute-modal-label";
            nameLabel.textContent = "Name";
            const nameInput = document.createElement("input");
            nameInput.id = "attribute-name-input";
            nameInput.type = "text";
            nameInput.className = "attribute-modal-input";
            nameInput.maxLength = 100;
            nameInput.addEventListener("input", updateCharCounter);
            nameInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    const typeSelect = document.getElementById("attribute-type-select");
                    const name = nameInput.value.trim();
                    const type = typeSelect ? typeSelect.value : "string";
                    if (name) {
                        vscode.postMessage({
                            type: "addAttribute",
                            attributeName: name,
                            attributeType: type
                        });
                        closeAttributeModal();
                    }
                } else if (e.key === "Escape") {
                    closeAttributeModal();
                }
            });
            const charCounter = document.createElement("div");
            charCounter.id = "attribute-char-counter";
            charCounter.className = "attribute-modal-char-counter";
            charCounter.textContent = "0/100";
            nameField.appendChild(nameLabel);
            nameField.appendChild(nameInput);
            nameField.appendChild(charCounter);

            const typeField = document.createElement("div");
            typeField.className = "attribute-modal-field";
            const typeLabel = document.createElement("label");
            typeLabel.className = "attribute-modal-label";
            typeLabel.textContent = "Type";
            const typeSelect = document.createElement("select");
            typeSelect.id = "attribute-type-select";
            typeSelect.className = "attribute-modal-select";

            const types = ["string", "number", "boolean", "Color3", "Vector2", "Vector3", "UDim", "UDim2", "BrickColor", "NumberRange", "NumberSequence", "ColorSequence"];
            for (const type of types) {
                const option = document.createElement("option");
                option.value = type;
                option.textContent = type;
                typeSelect.appendChild(option);
            }

            typeField.appendChild(typeLabel);
            typeField.appendChild(typeSelect);

            body.appendChild(nameField);
            body.appendChild(typeField);

            const footer = document.createElement("div");
            footer.className = "attribute-modal-footer";

            const saveButton = document.createElement("button");
            saveButton.className = "attribute-modal-button primary";
            saveButton.textContent = "Save";
            saveButton.addEventListener("click", () => {
                const name = nameInput.value.trim();
                const type = typeSelect.value;
                if (name) {
                    vscode.postMessage({
                        type: "addAttribute",
                        attributeName: name,
                        attributeType: type
                    });
                    closeAttributeModal();
                }
            });

            const cancelButton = document.createElement("button");
            cancelButton.className = "attribute-modal-button secondary";
            cancelButton.textContent = "Cancel";
            cancelButton.addEventListener("click", closeAttributeModal);

            footer.appendChild(saveButton);
            footer.appendChild(cancelButton);

            content.appendChild(body);
            content.appendChild(footer);
            modal.appendChild(content);

            modal.addEventListener("click", (e) => {
                if (e.target === modal) {
                    closeAttributeModal();
                }
            });

            document.body.appendChild(modal);
        }

        function updateCharCounter() {
            const nameInput = document.getElementById("attribute-name-input");
            const charCounter = document.getElementById("attribute-char-counter");
            if (nameInput && charCounter) {
                charCounter.textContent = `${nameInput.value.length}/100`;
            }
        }

        window.addEventListener("message", (event) => {
            const message = event.data;
            if (message && message.type === "updateProperties") {
                updateProperties(message);
            }
        });
    </script>
</body>

</html>