<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Properties</title>
    <link href="{{styleUri}}" rel="stylesheet">
</head>

<body>
    <div class="root">
        {{topbarHtml}}
        <div id="scroller" class="scroller">
            <div id="properties-container"></div>
        </div>
    </div>

    <script>
        const vscode = acquireVsCodeApi();

        let allProperties = [];
        const collapsedCategories = new Set();

        const container = document.getElementById("properties-container");
        { { scriptElements } }

        function updateProperties(message) {
            if (typeof message === 'object' && message.properties) {
                allProperties = Array.isArray(message.properties) ? message.properties : [];
                // Update title if node info is provided
                if (message.nodeName && message.nodeClassName) {
                    const titleElement = document.getElementById('properties-title');
                    if (titleElement) {
                        titleElement.textContent = `Properties - ${message.nodeClassName} - ${message.nodeName}`;
                    }
                }
            } else {
                // Legacy support for old format
                allProperties = Array.isArray(message) ? message : [];
            }
            render();
        }

        function groupByCategory(properties) {
            const categories = new Map();
            for (const prop of properties) {
                const categoryName = (prop.category || "Other").toString();
                if (!categories.has(categoryName)) categories.set(categoryName, []);
                categories.get(categoryName).push(prop);
            }
            return categories;
        }

        function matchesFilter(prop) {
            { { filterLogic } }
        }

        function render() {
            container.innerHTML = "";

            const filtered = allProperties.filter(matchesFilter);
            if (filtered.length === 0) {
                const empty = document.createElement("div");
                empty.className = "empty";
                empty.textContent = allProperties.length ? "No matching properties." : "No properties available.";
                container.appendChild(empty);
                return;
            }

            const categories = groupByCategory(filtered);
            const sortedCategoryNames = Array.from(categories.keys()).sort((a, b) => a.localeCompare(b));

            for (const categoryName of sortedCategoryNames) {
                const categoryProps = categories.get(categoryName) || [];

                const categoryRoot = document.createElement("div");
                categoryRoot.className = "category" + (collapsedCategories.has(categoryName) ? " collapsed" : "");

                const header = document.createElement("div");
                header.className = "category-header";

                const caret = document.createElement("div");
                caret.className = "caret";
                header.appendChild(caret);

                const title = document.createElement("div");
                title.textContent = categoryName;
                header.appendChild(title);

                header.addEventListener("click", () => {
                    if (collapsedCategories.has(categoryName)) collapsedCategories.delete(categoryName);
                    else collapsedCategories.add(categoryName);
                    render();
                });

                categoryRoot.appendChild(header);

                const rows = document.createElement("div");
                rows.className = "rows";

                for (const prop of categoryProps) {
                    rows.appendChild(createRow(prop));
                }

                categoryRoot.appendChild(rows);
                container.appendChild(categoryRoot);
            }
        }

        function createRow(prop) {
            const row = document.createElement("div");
            row.className = "property-row";

            const name = document.createElement("div");
            name.className = "property-name";
            name.textContent = prop.name || "";
            row.appendChild(name);

            const value = document.createElement("div");
            value.className = "property-value";
            value.appendChild(createEditor(prop));
            row.appendChild(value);

            return row;
        }

        function postSetProperty(propertyName, propertyValue) {
            vscode.postMessage({
                type: "setProperty",
                propertyName,
                propertyValue,
            });
        }

        function createEditor(prop) {
            if (prop && prop.isInstanceReference) {
                const wrapper = document.createElement("div");
                wrapper.className = "instance-link";

                if (prop.referencedInstanceId && prop.referencedInstanceName) {
                    const link = document.createElement("a");
                    link.href = "#";
                    link.textContent = prop.referencedInstanceName;
                    link.addEventListener("click", (e) => {
                        e.preventDefault();
                        vscode.postMessage({
                            type: "navigateToInstance",
                            instanceId: prop.referencedInstanceId
                        });
                    });
                    wrapper.appendChild(link);
                } else {
                    const none = document.createElement("div");
                    none.className = "none";
                    none.textContent = "None";
                    wrapper.appendChild(none);
                }

                return wrapper;
            }

            if (prop && prop.isEnum && Array.isArray(prop.enumValues)) {
                const select = document.createElement("select");
                select.className = "value-select";

                for (const enumValue of prop.enumValues) {
                    const option = document.createElement("option");
                    option.value = String(enumValue.value);
                    option.textContent = enumValue.name;
                    if (prop.value && prop.value.Value === enumValue.value) option.selected = true;
                    select.appendChild(option);
                }

                select.addEventListener("change", () => {
                    const selectedOption = select.options[select.selectedIndex];
                    postSetProperty(prop.name, { EnumName: selectedOption.textContent, EnumType: prop.type });
                });

                return select;
            }

            switch (prop.type) {
                case "bool": {
                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.className = "value-checkbox";
                    checkbox.checked = !!prop.value;

                    checkbox.addEventListener("change", () => {
                        postSetProperty(prop.name, checkbox.checked);
                    });

                    return checkbox;
                }

                case "string": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    input.value = prop.value ?? "";

                    input.addEventListener("change", () => {
                        postSetProperty(prop.name, input.value);
                    });

                    return input;
                }

                case "number":
                case "int":
                case "float":
                case "double": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    input.value = prop.value ?? "0";

                    input.addEventListener("change", () => {
                        const raw = (input.value || "").trim();
                        const numericValue = prop.type.includes("int") ? parseInt(raw, 10) : parseFloat(raw);
                        if (!Number.isFinite(numericValue)) return;
                        postSetProperty(prop.name, numericValue);
                    });

                    return input;
                }

                case "Vector3": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";

                    if (prop.value && typeof prop.value === "object") {
                        input.value = `${prop.value.X.toFixed(3)}, ${prop.value.Y.toFixed(3)}, ${prop.value.Z.toFixed(3)}`;
                    } else {
                        input.value = "0, 0, 0";
                    }

                    input.addEventListener("change", () => {
                        const parts = (input.value || "").split(",").map(s => parseFloat(s.trim()));
                        if (parts.length !== 3 || parts.some(n => !Number.isFinite(n))) return;
                        postSetProperty(prop.name, { X: parts[0], Y: parts[1], Z: parts[2] });
                    });

                    return input;
                }

                case "UDim2": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";

                    if (prop.value && prop.value.X && prop.value.Y) {
                        input.value = `${prop.value.X.Scale}, ${prop.value.X.Offset}, ${prop.value.Y.Scale}, ${prop.value.Y.Offset}`;
                    } else {
                        input.value = "0, 0, 0, 0";
                    }

                    input.addEventListener("change", () => {
                        const parts = (input.value || "").split(",").map(s => parseFloat(s.trim()));
                        if (parts.length !== 4 || parts.some(n => !Number.isFinite(n))) return;
                        postSetProperty(prop.name, {
                            X: { Scale: parts[0], Offset: parts[1] },
                            Y: { Scale: parts[2], Offset: parts[3] },
                        });
                    });

                    return input;
                }

                case "Color3": {
                    const input = document.createElement("input");
                    input.type = "color";
                    input.className = "value-input";
                    input.style.padding = "0";
                    input.style.height = "18px";

                    if (prop.value && typeof prop.value === "object") {
                        const r = Math.max(0, Math.min(255, Math.round((prop.value.R ?? 0) * 255)));
                        const g = Math.max(0, Math.min(255, Math.round((prop.value.G ?? 0) * 255)));
                        const b = Math.max(0, Math.min(255, Math.round((prop.value.B ?? 0) * 255)));
                        input.value = `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
                    } else {
                        input.value = "#000000";
                    }

                    input.addEventListener("change", () => {
                        const r = parseInt(input.value.slice(1, 3), 16) / 255;
                        const g = parseInt(input.value.slice(3, 5), 16) / 255;
                        const b = parseInt(input.value.slice(5, 7), 16) / 255;
                        postSetProperty(prop.name, { R: r, G: g, B: b });
                    });

                    return input;
                }

                case "CFrame": {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    input.placeholder = "Position (X, Y, Z)";

                    if (prop.value && typeof prop.value === "object" && prop.value.Position) {
                        const pos = prop.value.Position;
                        if (pos.X !== undefined && pos.Y !== undefined && pos.Z !== undefined) {
                            input.value = `${pos.X.toFixed(3)}, ${pos.Y.toFixed(3)}, ${pos.Z.toFixed(3)}`;
                        }
                    }

                    input.addEventListener("change", () => {
                        const parts = (input.value || "").split(",").map(s => parseFloat(s.trim()));
                        if (parts.length !== 3 || parts.some(n => !Number.isFinite(n))) return;
                        postSetProperty(prop.name, {
                            Position: { X: parts[0], Y: parts[1], Z: parts[2] },
                            Rotation: { X: 0, Y: 0, Z: 0 } // Default identity rotation
                        });
                    });

                    return input;
                }

                default: {
                    const input = document.createElement("input");
                    input.type = "text";
                    input.className = "value-input";
                    input.value = prop.value != null ? String(prop.value) : "";

                    input.addEventListener("change", () => {
                        const raw = input.value;
                        try {
                            postSetProperty(prop.name, JSON.parse(raw));
                        } catch {
                            postSetProperty(prop.name, raw);
                        }
                    });

                    return input;
                }
            }
        }

        window.addEventListener("message", (event) => {
            const message = event.data;
            if (message && message.type === "updateProperties") {
                updateProperties(message);
            }
        });
    </script>
</body>

</html>